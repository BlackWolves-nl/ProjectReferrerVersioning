using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;
using System.Windows.Shapes;

namespace WolvePack.VS.Extensions.ProjectReferrerVersioning.Services
{
    /// <summary>
    /// SVG export that mirrors current Canvas contents (nodes, edges, arrowheads, badges, text).
    /// Fix: Use #RRGGBB (SVG 1.1) + separate opacity instead of #AARRGGBB (was causing color shift to purple).
    /// Uses per-rectangle userSpaceOnUse gradients for fidelity with WPF LinearGradientBrush.
    /// </summary>
    internal static class SvgExportService
    {
        private class RectGradient { public Rectangle Rect; public LinearGradientBrush Brush; public string Id; public double X; public double Y; public double W; public double H; }
        private class TextExport
        {
            public TextBlock Tb; public double X; public double Y; public double ContainerW; public double ContainerH; public FrameworkElement Container;
        }

        public static void Export(Canvas canvas, string filePath)
        {
            if (canvas == null || string.IsNullOrWhiteSpace(filePath)) return;
            canvas.UpdateLayout();
            double width = canvas.Width <= 0 ? canvas.ActualWidth : canvas.Width;
            double height = canvas.Height <= 0 ? canvas.ActualHeight : canvas.Height;
            if (width <= 0) width = 1; if (height <= 0) height = 1;

            // Gradients
            List<RectGradient> gradients = new List<RectGradient>();
            int gradIndex = 0;
            foreach (UIElement child in canvas.Children)
            {
                if (child is Rectangle r && r.Visibility == Visibility.Visible && r.Fill is LinearGradientBrush lgb)
                {
                    gradients.Add(new RectGradient
                    {
                        Rect = r,
                        Brush = lgb,
                        Id = "g" + (++gradIndex),
                        X = Canvas.GetLeft(r),
                        Y = Canvas.GetTop(r),
                        W = r.Width,
                        H = r.Height
                    });
                }
            }

            // Collect ALL text blocks recursively (captures badge counts inside Grids)
            List<TextExport> texts = new List<TextExport>();
            HashSet<TextBlock> seen = new HashSet<TextBlock>();
            CollectTextBlocks(canvas, 0, 0, texts, seen);

            StringBuilder sb = new StringBuilder();
            sb.AppendLine("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
            sb.AppendLine("<!-- Generated by Project Referrer Chain Explorer - SVG export -->");
            sb.AppendLine($"<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"{width.ToString(CultureInfo.InvariantCulture)}\" height=\"{height.ToString(CultureInfo.InvariantCulture)}\" viewBox=\"0 0 {width.ToString(CultureInfo.InvariantCulture)} {height.ToString(CultureInfo.InvariantCulture)}\">");

            // Defs
            sb.AppendLine("  <defs>");
            foreach (var g in gradients)
            {
                double x1 = g.X + g.Brush.StartPoint.X * g.W;
                double y1 = g.Y + g.Brush.StartPoint.Y * g.H;
                double x2 = g.X + g.Brush.EndPoint.X * g.W;
                double y2 = g.Y + g.Brush.EndPoint.Y * g.H;
                sb.AppendLine($"    <linearGradient id=\"{g.Id}\" gradientUnits=\"userSpaceOnUse\" x1=\"{x1.ToString(CultureInfo.InvariantCulture)}\" y1=\"{y1.ToString(CultureInfo.InvariantCulture)}\" x2=\"{x2.ToString(CultureInfo.InvariantCulture)}\" y2=\"{y2.ToString(CultureInfo.InvariantCulture)}\">");
                foreach (GradientStop stop in g.Brush.GradientStops)
                {
                    sb.Append("      <stop offset=\"")
                      .Append(stop.Offset.ToString(CultureInfo.InvariantCulture))
                      .Append("\" stop-color=\"")
                      .Append(ToRgb(stop.Color))
                      .Append("\" stop-opacity=\"")
                      .Append((stop.Color.A / 255.0).ToString("0.###", CultureInfo.InvariantCulture))
                      .AppendLine("\" />");
                }
                sb.AppendLine("    </linearGradient>");
            }
            sb.AppendLine("  </defs>");

            // Background
            if (canvas.Background is SolidColorBrush bg)
            {
                sb.Append("  <rect x=\"0\" y=\"0\" width=\"")
                  .Append(width.ToString(CultureInfo.InvariantCulture))
                  .Append("\" height=\"")
                  .Append(height.ToString(CultureInfo.InvariantCulture))
                  .Append("\" fill=\"")
                  .Append(ToRgb(bg.Color))
                  .Append("\" fill-opacity=\"")
                  .Append((bg.Color.A / 255.0).ToString("0.###", CultureInfo.InvariantCulture))
                  .AppendLine("\" />");
            }

            // Lines & arrows
            foreach (UIElement child in canvas.Children)
            {
                if (child.Visibility != Visibility.Visible) continue;
                if (child is Line line)
                    sb.AppendLine(RenderLine(line));
                else if (child is Polygon poly)
                    sb.AppendLine(RenderPolygon(poly));
            }

            // Shapes
            foreach (UIElement child in canvas.Children)
            {
                if (child.Visibility != Visibility.Visible) continue;
                if (child is Rectangle rect)
                    sb.AppendLine(RenderRectangle(rect, gradients));
                else if (child is Ellipse ell)
                    sb.AppendLine(RenderEllipse(ell));
                else if (child is Border b)
                    sb.AppendLine(RenderBorder(b));
            }

            // Text
            foreach (var t in texts)
            {
                if (t.Tb.Visibility != Visibility.Visible) continue;
                if (HasHiddenAncestor(t.Tb)) continue; // respect hidden parent (e.g., pill Border/Grid)
                string text = t.Tb.Text;
                if (string.IsNullOrEmpty(text)) continue;

                // Skip pill (expanded badge) text entirely
                if (IsPillText(t))
                    continue;

                // Unified badge detection (root 'R' and circular numeric badge)
                if (TryGetBadgeCenter(t, canvas, out double badgeCX, out double badgeCY))
                {
                    string fillB = SolidBrushToRgb(t.Tb.Foreground); double fillOpB = BrushAlpha(t.Tb.Foreground);
                    string weightB = t.Tb.FontWeight.ToOpenTypeWeight() >= FontWeights.Bold.ToOpenTypeWeight() ? "bold" : "normal";
                    sb.Append("  <text x=\"").Append(badgeCX.ToString(CultureInfo.InvariantCulture)).Append("\" y=\"")
                      .Append(badgeCY.ToString(CultureInfo.InvariantCulture)).Append("\" font-family=\"")
                      .Append(Escape(t.Tb.FontFamily.Source)).Append("\" font-size=\"")
                      .Append(t.Tb.FontSize.ToString(CultureInfo.InvariantCulture)).Append("\" font-weight=\"")
                      .Append(weightB).Append("\" text-anchor=\"middle\" fill=\"")
                      .Append(fillB).Append("\" fill-opacity=\"").Append(fillOpB.ToString("0.###", CultureInfo.InvariantCulture)).Append("\" dominant-baseline=\"middle\" alignment-baseline=\"middle\">")
                      .Append(Escape(text)).AppendLine("</text>");
                    continue;
                }

                // Absolute top-left of TextBlock relative to canvas (fallback generic text)
                Point abs = new Point(t.X, t.Y);
                try { abs = t.Tb.TransformToVisual(canvas).Transform(new Point(0, 0)); } catch { }

                double tbActualW = t.Tb.ActualWidth > 0 ? t.Tb.ActualWidth : (t.Tb.Width > 0 ? t.Tb.Width : t.ContainerW);
                double tbActualH = t.Tb.ActualHeight > 0 ? t.Tb.ActualHeight : (t.Tb.Height > 0 ? t.Tb.Height : t.ContainerH);
                bool vertCenter = (t.Tb.VerticalAlignment == VerticalAlignment.Center || t.Tb.VerticalAlignment == VerticalAlignment.Stretch) && tbActualH > 0;
                string anchor = t.Tb.TextAlignment == TextAlignment.Center || t.Tb.HorizontalAlignment == HorizontalAlignment.Center ? "middle" : t.Tb.TextAlignment == TextAlignment.Right || t.Tb.HorizontalAlignment == HorizontalAlignment.Right ? "end" : "start";
                double containerW = ResolveContainerWidth(t, tbActualW);
                double baseline = vertCenter ? (abs.Y + tbActualH / 2.0) : (abs.Y + t.Tb.FontSize * 0.8);
                double drawX = abs.X;
                if (anchor == "middle") drawX += containerW / 2.0; else if (anchor == "end") drawX += containerW;
                string weight = t.Tb.FontWeight.ToOpenTypeWeight() >= FontWeights.Bold.ToOpenTypeWeight() ? "bold" : "normal";
                string fill = SolidBrushToRgb(t.Tb.Foreground); double fillOpacity = BrushAlpha(t.Tb.Foreground);
                string baselineAttrs = vertCenter ? " dominant-baseline=\"middle\" alignment-baseline=\"middle\"" : string.Empty;
                sb.Append("  <text x=\"").Append(drawX.ToString(CultureInfo.InvariantCulture)).Append("\" y=\"")
                  .Append(baseline.ToString(CultureInfo.InvariantCulture)).Append("\" font-family=\"")
                  .Append(Escape(t.Tb.FontFamily.Source)).Append("\" font-size=\"")
                  .Append(t.Tb.FontSize.ToString(CultureInfo.InvariantCulture)).Append("\" font-weight=\"")
                  .Append(weight).Append("\" text-anchor=\"").Append(anchor).Append("\" fill=\"")
                  .Append(fill).Append("\" fill-opacity=\"").Append(fillOpacity.ToString("0.###", CultureInfo.InvariantCulture)).Append("\"")
                  .Append(baselineAttrs).Append(">")
                  .Append(Escape(text)).AppendLine("</text>");
            }

            sb.AppendLine("</svg>");
            File.WriteAllText(filePath, sb.ToString(), Encoding.UTF8);
        }

        private static void CollectTextBlocks(FrameworkElement element, double offsetX, double offsetY, List<TextExport> list, HashSet<TextBlock> seen)
        {
            if (element == null) return;
            double left = Canvas.GetLeft(element); if (double.IsNaN(left)) left = 0;
            double top = Canvas.GetTop(element); if (double.IsNaN(top)) top = 0;
            double newX = offsetX + left;
            double newY = offsetY + top;

            if (element is TextBlock tb)
            {
                if (seen.Add(tb))
                {
                    list.Add(new TextExport { Tb = tb, X = newX, Y = newY, ContainerW = element.ActualWidth, ContainerH = element.ActualHeight, Container = element });
                }
            }

            int count = VisualTreeHelper.GetChildrenCount(element);
            for (int i = 0; i < count; i++)
            {
                DependencyObject child = VisualTreeHelper.GetChild(element, i);
                if (child is FrameworkElement fe)
                    CollectTextBlocks(fe, newX, newY, list, seen);
            }
        }

        private static double ResolveContainerWidth(TextExport t, double fallback)
        {
            double best = fallback;
            FrameworkElement current = t.Container;
            int guard = 0;
            while (current != null && guard++ < 8)
            {
                if (current is Canvas) break; // never use canvas width
                if (current is Border || current is Grid || current is Rectangle || current is Ellipse)
                {
                    double candidate = current.Width > 0 ? current.Width : (current.ActualWidth > 0 ? current.ActualWidth : best);
                    // Accept candidate if it's moderately larger but not excessively large
                    if (candidate > best * 1.1 && candidate < best * 6 && candidate <= 400)
                        best = candidate;
                }
                var parent = VisualTreeHelper.GetParent(current) as FrameworkElement;
                if (parent == null) break;
                current = parent;
            }
            return best;
        }

        #region Rendering helpers
        private static string RenderLine(Line l)
        {
            string stroke = SolidBrushToRgb(l.Stroke); double strokeOpacity = BrushAlpha(l.Stroke) * l.Opacity;
            return $"  <line x1=\"{l.X1.ToString(CultureInfo.InvariantCulture)}\" y1=\"{l.Y1.ToString(CultureInfo.InvariantCulture)}\" x2=\"{l.X2.ToString(CultureInfo.InvariantCulture)}\" y2=\"{l.Y2.ToString(CultureInfo.InvariantCulture)}\" stroke=\"{stroke}\" stroke-width=\"{l.StrokeThickness.ToString(CultureInfo.InvariantCulture)}\" stroke-linecap=\"round\" stroke-opacity=\"{strokeOpacity.ToString("0.###", CultureInfo.InvariantCulture)}\" />";
        }
        private static string RenderPolygon(Polygon p)
        {
            string fill = SolidBrushToRgb(p.Fill); double fillOpacity = BrushAlpha(p.Fill) * p.Opacity;
            List<string> pts = new List<string>();
            foreach (Point pt in p.Points) pts.Add(pt.X.ToString(CultureInfo.InvariantCulture) + "," + pt.Y.ToString(CultureInfo.InvariantCulture));
            return $"  <polygon points=\"{string.Join(" ", pts)}\" fill=\"{fill}\" fill-opacity=\"{fillOpacity.ToString("0.###", CultureInfo.InvariantCulture)}\" />";
        }
        private static string RenderRectangle(Rectangle r, List<RectGradient> gradients)
        {
            double x = Canvas.GetLeft(r); double y = Canvas.GetTop(r);
            string fill; double fillOpacity = 1.0;
            if (r.Fill is LinearGradientBrush)
            {
                var g = gradients.Find(gr => gr.Rect == r); fill = g != null ? $"url(#{g.Id})" : "none";
            }
            else { fill = SolidBrushToRgb(r.Fill); fillOpacity = BrushAlpha(r.Fill); }
            string stroke = SolidBrushToRgb(r.Stroke); double strokeOpacity = BrushAlpha(r.Stroke);
            return $"  <rect x=\"{x.ToString(CultureInfo.InvariantCulture)}\" y=\"{y.ToString(CultureInfo.InvariantCulture)}\" width=\"{r.Width.ToString(CultureInfo.InvariantCulture)}\" height=\"{r.Height.ToString(CultureInfo.InvariantCulture)}\" rx=\"{r.RadiusX}\" ry=\"{r.RadiusY}\" fill=\"{fill}\" fill-opacity=\"{fillOpacity.ToString("0.###", CultureInfo.InvariantCulture)}\" stroke=\"{stroke}\" stroke-width=\"{r.StrokeThickness}\" stroke-opacity=\"{strokeOpacity.ToString("0.###", CultureInfo.InvariantCulture)}\" />";
        }
        private static string RenderEllipse(Ellipse e)
        {
            double x = Canvas.GetLeft(e); double y = Canvas.GetTop(e);
            double cx = x + e.Width / 2.0; double cy = y + e.Height / 2.0;
            string fill = SolidBrushToRgb(e.Fill); double fillOpacity = BrushAlpha(e.Fill);
            string stroke = SolidBrushToRgb(e.Stroke); double strokeOpacity = BrushAlpha(e.Stroke);
            return $"  <ellipse cx=\"{cx.ToString(CultureInfo.InvariantCulture)}\" cy=\"{cy.ToString(CultureInfo.InvariantCulture)}\" rx=\"{(e.Width/2.0).ToString(CultureInfo.InvariantCulture)}\" ry=\"{(e.Height/2.0).ToString(CultureInfo.InvariantCulture)}\" fill=\"{fill}\" fill-opacity=\"{fillOpacity.ToString("0.###", CultureInfo.InvariantCulture)}\" stroke=\"{stroke}\" stroke-width=\"{e.StrokeThickness}\" stroke-opacity=\"{strokeOpacity.ToString("0.###", CultureInfo.InvariantCulture)}\" />";
        }
        private static string RenderBorder(Border b)
        {
            double x = Canvas.GetLeft(b); double y = Canvas.GetTop(b); if (double.IsNaN(x) || double.IsNaN(y)) return string.Empty;
            double w = b.Width > 0 ? b.Width : b.ActualWidth; double h = b.Height > 0 ? b.Height : b.ActualHeight;
            CornerRadius cr = b.CornerRadius; double rx = (cr.TopLeft + cr.TopRight + cr.BottomLeft + cr.BottomRight) / 4.0;
            string fill = SolidBrushToRgb(b.Background); double fillOpacity = BrushAlpha(b.Background);
            string stroke = SolidBrushToRgb(b.BorderBrush); double strokeOpacity = BrushAlpha(b.BorderBrush);
            return $"  <rect x=\"{x.ToString(CultureInfo.InvariantCulture)}\" y=\"{y.ToString(CultureInfo.InvariantCulture)}\" width=\"{w.ToString(CultureInfo.InvariantCulture)}\" height=\"{h.ToString(CultureInfo.InvariantCulture)}\" rx=\"{rx.ToString(CultureInfo.InvariantCulture)}\" ry=\"{rx.ToString(CultureInfo.InvariantCulture)}\" fill=\"{fill}\" fill-opacity=\"{fillOpacity.ToString("0.###", CultureInfo.InvariantCulture)}\" stroke=\"{stroke}\" stroke-width=\"{b.BorderThickness.Left.ToString(CultureInfo.InvariantCulture)}\" stroke-opacity=\"{strokeOpacity.ToString("0.###", CultureInfo.InvariantCulture)}\" />";
        }
        #endregion

        #region Color helpers
        private static string ToRgb(Color c) => $"#{c.R:X2}{c.G:X2}{c.B:X2}";
        private static string SolidBrushToRgb(Brush b) => b is SolidColorBrush scb ? ToRgb(scb.Color) : "none";
        private static double BrushAlpha(Brush b) => b is SolidColorBrush scb ? scb.Color.A / 255.0 : 1.0;
        private static string Escape(string s) => string.IsNullOrEmpty(s) ? string.Empty : s.Replace("&","&amp;").Replace("<","&lt;").Replace(">","&gt;").Replace("\"","&quot;");
        #endregion

        private static bool HasHiddenAncestor(FrameworkElement fe)
        {
            var current = fe as FrameworkElement; int guard = 0;
            while (current != null && guard++ < 12)
            {
                if (current != fe && current.Visibility != Visibility.Visible) return true;
                current = VisualTreeHelper.GetParent(current) as FrameworkElement;
            }
            return false;
        }

        private static bool IsPillText(TextExport t)
        {
            FrameworkElement current = t.Tb; int guard = 0;
            while (current != null && guard++ < 8)
            {
                if (current is Border b)
                {
                    double h = b.Height > 0 ? b.Height : b.ActualHeight;
                    double w = b.Width > 0 ? b.Width : b.ActualWidth;
                    if (b.Visibility != Visibility.Visible && h > 0 && w > h * 1.6 && b.CornerRadius.TopLeft >= h / 2 - 2) return true; // hidden pill border
                }
                current = VisualTreeHelper.GetParent(current) as FrameworkElement;
            }
            return false;
        }
        private static bool TryGetBadgeCenter(TextExport t, Canvas canvas, out double cx, out double cy)
        {
            cx = cy = 0;
            double fudgeX = 0.0; // small optical adjustment left
            double fudgeY = 1.0; // small optical adjustment down
            // Attempt ancestor ellipse first
            Ellipse ellipse = null; int guard = 0; FrameworkElement current = t.Tb;
            while (current != null && guard++ < 8)
            {
                if (current is Ellipse e && e.Width >= 16 && e.Width <= 64 && Math.Abs(e.Width - e.Height) < 2) { ellipse = e; break; }
                current = VisualTreeHelper.GetParent(current) as FrameworkElement;
            }

            // If not found, attempt sibling search: locate an ellipse on the canvas whose bounds contain text center
            if (ellipse == null)
            {
                Point absTL; // absolute top-left of text
                try { absTL = t.Tb.TransformToVisual(canvas).Transform(new Point(0, 0)); }
                catch { absTL = new Point(t.X, t.Y); }
                double tbW = t.Tb.ActualWidth > 0 ? t.Tb.ActualWidth : (t.Tb.Width > 0 ? t.Tb.Width : t.ContainerW);
                double tbH = t.Tb.ActualHeight > 0 ? t.Tb.ActualHeight : (t.Tb.Height > 0 ? t.Tb.Height : t.ContainerH);
                double textCX = absTL.X + tbW / 2.0;
                double textCY = absTL.Y + tbH / 2.0;
                foreach (UIElement child in canvas.Children)
                {
                    Ellipse e = child as Ellipse;
                    if (e == null) continue;
                    double ex = Canvas.GetLeft(e); double ey = Canvas.GetTop(e);
                    if (double.IsNaN(ex) || double.IsNaN(ey)) continue;
                    double ew = e.Width; double eh = e.Height;
                    if (ew < 16 || ew > 64) continue;
                    if (Math.Abs(ew - eh) > 2) continue; // not near circular
                    if (textCX >= ex && textCX <= ex + ew && textCY >= ey && textCY <= ey + eh)
                    {
                        ellipse = e; break;
                    }
                }
            }

            if (ellipse == null) return false;
            double lx = Canvas.GetLeft(ellipse); double ly = Canvas.GetTop(ellipse);
            if (!double.IsNaN(lx) && !double.IsNaN(ly))
            {
                cx = lx + ellipse.Width / 2.0 + fudgeX;
                cy = ly + ellipse.Height / 2.0 + fudgeY;
                return true;
            }
            try
            {
                Point ep = ellipse.TransformToVisual(canvas).Transform(new Point(0, 0));
                cx = ep.X + ellipse.Width / 2.0 + fudgeX;
                cy = ep.Y + ellipse.Height / 2.0 + fudgeY;
                return true;
            }
            catch { }
            return false;
        }
    }
}
